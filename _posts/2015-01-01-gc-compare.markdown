---
layout: post
title:  "JAVA,PHP和Python的GC比较"
date:   2015-01-01 13:58:57
published: true
categories: coding-java
---

* 目录
{:toc}

## 一些说明：
> 目前主要收集到的关于gc的知识主要是涵盖`java`， `php`，`python` 这三种语言的，暂时不考虑其他语言的gc实现。
 关于gc, 对gc 的了解，对于编程中性能的提升可能不会有很大的帮助，
 但是对于某些奇怪的问题的把握，对一门语言整体性能的评估和可能的漏洞都是有益处的。
 
## 引用计数

> 首先要明确的一点是针对`java`，`php`，`python`，引用计数从`jvm`最近的若干版本，`php` 5.3以来，均已经被舍弃，`python`依旧保留这种简单有效，但缺陷明显的算法。

> 统一来说，对于一个对象，在内存中存在的模型除了`type`, `value`以外，还会存在一个`refcount`(引用计数), 表示该对象被多少个变量所引用，
每增加一个该对象的引用，其`refcount` 就会加1，每减少一个对该对象的引用，`refcount` 就会减1,这样被n个变量引用的`refcount` 就是n,
当n=0时表示无此对象的引用，是为垃圾可以回收。该算法就是遍历内存中`refcount`为0的对象，并将之清除。

##### 引用计数的缺陷：

> 针对多个对象循环引用的情况下，每个对象单独来看引用计数均不为0，但是整体来看，没有被外部变量所引用，也不会在未来被任何变量访问
存在了引用计数不为0的垃圾对象，所以引用计数算法对于处理循环引用的对象是有问题的，此类型对象的增多会引起内存泄露，产生错误。

## JAVA的GC实现

参考：《深入理解Java虚拟机：JVM高级特性与最佳实践》周志明 著，机械工业出版社，2011.6

#### 根搜索算法

> 堆空间中有一些特定的对象是一定非垃圾的对象，把这些对象作为根节点，从根节点开始按照对象之间的引用链遍历堆空间中得对象，
如果能够到达则为非垃圾，不能够到达的就是垃圾对象，可以将这些对象做GC。
能够作为根节点的对象包括

* 虚拟机栈栈帧中本地变量表引用的对象
* 方法区中得类静态属性引用的对象
* 方法区常量引用的对象
* 本地方法栈中JNI(跨语言平台的方法调用)的引用的对象

> 一个问题，这样标记清除完成后得到的内存空间是不连续的，当需要申请更大连续空间时，很可能引无法申请到连续空间而出发另一次GC,造成堆空间空白区域碎片化。

##### 标记-复制-清除

> 将堆空间分为A，B两部分，当A中堆空间达到需要GC的时候，将A空间的所有对象按照跟搜索算法标记为垃圾与非垃圾对象，将所有非垃圾对象copy到B区域，然后清除A区域，得到连续的堆内存空间。

##### 标记-清除-整理

> 针对做GC的堆空间，当根搜索算法完成并清除掉垃圾对象以后，对整个空间做整理得到连续的空白堆空间。

#### 新生代和老年代 (分代收集)

> 根据对象的存货周期将内存划分为新生代和老年代，新生代中收集率很高，GC后得到的对象很少，所以适合使用`标记-复制-清除`的方式。
而老年代中大部分对象不会被GC,适合使用`标记-整理-清除`的方式。

#### eden 和 survivor

> 根据垃圾回收的特点，将整个对空间分为Eden, From Survivor, To Survivor 三个空间，一般比例为 1：8：1，
针对To Survivor 为备份空间。GC触发时，From Survivor 和Eden， 会将垃圾回收剩余的对象copy到To Survivor空间中，
同时To Survivor 区域作为新的From Survivor ， 而旧的From Survivor 清空 作为新的To Survivor 区域，
From Survivor 和 To Survivor 空间大小比例维持8：1.这样的优点是堆空间只有10%的区域留作垃圾回收之用。

## PHP的GC实现

参考文档：[PHP MANUAL](http://php.net/manual/zh/features.gc.collecting-cycles.php)。
 
![php-gc](http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png)

> 为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),
放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。
仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。看上图的步骤 A。

> 在步骤 B 中，模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减"1"，如果某个普通变量引用计数变成0了，
就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次"1",不对的吧）。

> 在步骤 C 中，模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。
同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。
这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。

> 算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。
复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。

> 现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。
默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：zend.enable_gc 。


## Python的GC实现

#### Python中的对象

> `Python`中所有的对象均被一个`PyObject`定义,源码中其定义为
{% highlight c %}

typedef struct _object {
    PyObject_HEAD
} PyObject;

{% endhighlight %}

{% highlight c %}

# define PyObject_HEAD                   \
    _PyObject_HEAD_EXTRA                \
    Py_ssize_t ob_refcnt;               \
    struct _typeobject *ob_type;

{% endhighlight %}

ob_refcnt就是引用计数器，Python中没有去掉引用计数的垃圾回收机制，并且在此基础上，依旧使用了之前叙述过的根搜索算法及分代技术。这里不再赘述。



